反向传播的一个重要的方面是它的计算效率。为了理解这一点，让我们考察计算误差函数的导数需要的次数与网络中权值与偏置的总量$$ W $$之间的关系。误差函数单次计算（对于给定输入模式），当$$ W $$充分大时，需要$$ O(W) $$次操作。这是因为除非网络的连接十分稀疏，否则权值的数量通常大大超过单元的数量，所以正向传播的计算复杂度主要取决于公式（5.48)的求和项的计算，而激活函数的计算就相对耗时较少。式（5.48）的求和项中的每一项需要一次乘法和一次加法，从而整体的计算开销为$$ O(W) $$。    

反向传播计算误差函数导数的另一种方法是使用有限差。这可以通过让每个权值有一个扰动，然后使用

$$
\frac{\partial E_n}{\partial w_{ji}} = \frac{E_n(w_{ji} + \epsilon) - E_n(w_{ji})}{\epsilon} + O(\epsilon) \tag{5.68}
$$

来近似导数，其中$$ \epsilon \ll 1 $$。在软件模拟中，通过让$$ \epsilon $$变小，可以提高导数近似的精度，直到数值下溢问题出现。使用形式为

$$
\frac{\partial E_n}{\partial w_{ji}} = \frac{E_n(w_{ji} + \epsilon) - E_n(w_{ji} - \epsilon)}{2\epsilon} + O(\epsilon^2) \tag{5.69}
$$

的对称的中心差（central difference）可以极大的提高有限差的精度。在这种情况下，$$ O(\epsilon) $$修正取消了，这可以通过式（5.69）右手边的泰勒展开来证明，但是它产生的修正项$$ O(\epsilon^2) $$。然而，与式（5.68）相比，计算步骤数大约变成了二倍。    

计算数值导数的最主要问题是计算复杂度为$$ O(W) $$这一理想性质不成立。每次正向传播都需要$$ O(W) $$步，而网络中有$$ W $$个权值都需要单独加扰动，因此整体的时间复杂度为$$ O(W^2) $$。    

然而，由于将反向传播算法计算的导数与使用中心差计算的导数进行对比，可以有效地检查反向传播算法的执行正确性，所以数值导数的方法在实际应用中具有重要的作用。在实际应用中，当训练一个网络时，因为反向传播算法具有最高的精度和效率，所以因该使用它来计算导数。但是，还需要使用式（5.69）的数值导数的结果与之对比，来检查执行的正确性。    


